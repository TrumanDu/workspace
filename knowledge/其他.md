## 数据库

1.索引的种类

哈希索引、B树、B+树、红黑树

## 分布式锁

三种方式，1.数据库实现2.基于zookeeper 临时节点，值最小的获取锁3.基于redis

参考[distributed-locks](http://youzhixueyuan.com/3-implementations-of-distributed-locks.html)

## 网络

### tcp 为什么三次握手？

加入我们去掉第三次握手，s发送确认信息后，即认为建立连接，但是加入c未收到确认，那么就会浪费资源。如果大量的这种情况，S会崩溃。 

### 为什么断开TCP连接需要进行四次握手 ？

因为TCP连接是全双工的网络协议，允许同时通信的双方同时进行数据的收发，同样也允许收发两个方向的连接被独立关闭，以避免client数据发送完毕，向server发送FIN关闭连接，而server还有发送到client的数据没有发送完毕的情况。所以关闭TCP连接需要进行四次握手，每次关闭一个方向上的连接需要FIN和ACK两次握手

### ping 原理

arp地址解析协议
- 同一个网段
- 不同网段

## 常用负载均衡算法

- 轮询法
- 加权轮询法
- 随机法
- 加权随机法
- 源地址哈希法（hash%n）
- 最小连接数法


## 分布式ID生成

### 雪花算法

64bit 

- 第一个部分，是 1 个 bit：0，这个是无意义的。
- 第二个部分是 41 个 bit：表示的是时间戳。
- 第三个部分是 5 个 bit：表示的是机房 id，10001。
- 第四个部分是 5 个 bit：表示的是机器 id，1 1001。
- 第五个部分是 12 个 bit：表示的序号

### 数据库自增主键

### redis

Redis的原子操作 INCR和INCRBY来实现

假如一个集群中有5台Redis。可以初始化每台Redis的值分别是1,2,3,4,5，然后步长都是5

### zookeeper

持久顺序节点特性
### UUID

### [微信消息ID生成](https://zhuanlan.zhihu.com/p/46404167)

微信消息序列号需要保证两个特性：**唯一性** ，**顺序性**

原先每条消息一个自增且唯一的消息ID分拆成两个关键属性——消息ID（msgId）、消息序列号（seqId）

msgId可以用UUID

接下来只用保证seqId就好了。

1. 内存中储存最近一个分配出去的sequence：cur_seq，以及分配上限：max_seq；
2. 分配sequence时，将cur_seq++，同时与分配上限max_seq比较：如果cur_seq > max_seq，将分配上限提升一个步长max_seq += step，并持久化max_seq；
3. 重启时，读出持久化的max_seq，赋值给cur_seq。

为了避免重启读取大量的max_seq，**分号段共享存储**，也就是多个group共享一个max_seq

## 分布式事务

- XA 方案（2PC/3PC）
- TCC 方案（Try - Confirm - Cancel）
- 可靠消息最终一致性方案

2PC : 需要一个协调者，存在单点问题

3PC : 在2PC阶段增加预确认阶段，超时机制等

## 设计一个高并发系统

主要考虑如下几点：
- 系统拆分
- 缓存
- MQ
- 读写分离
- 分库分表
- 加机器


## 设计秒杀系统

需要考虑解决以下问题：
- 超卖
- 防黑产
- 用户体验